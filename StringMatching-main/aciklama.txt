Aynen bu metin senin **string matching analiz projesini** Ã§ok gÃ¼zel Ã¶zetlemiÅŸ â€” ama sen â€œbunu bana **Ã§ok daha detaylÄ±**, kapsamlÄ±, dÃ¼zgÃ¼n bir rapor formatÄ±nda aÃ§Ä±klaâ€ diyorsun.
AÅŸaÄŸÄ±da **tam olarak ders/proje raporuna koyabileceÄŸin**, profesyonel ve teknik bir aÃ§Ä±klama veriyorum.
Hem anlaÅŸÄ±lÄ±r, hem akademik, hem de senin kod mimarine birebir uygun anlatÄ±yorum.

---

# ğŸ“Œ **STRING MATCHING ANALÄ°Z SÄ°STEMÄ° â€” DetaylÄ± Proje AÃ§Ä±klamasÄ±**

Bu proje, klasik ve modern string matching algoritmalarÄ±nÄ± bir arada test edebilen, performanslarÄ±nÄ± Ã¶lÃ§en, hangi algoritmanÄ±n hangi senaryoda daha iyi Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± analiz eden bir **benchmarking** ve **algorithm selection** sistemidir.

AmaÃ§ yalnÄ±zca algoritmalarÄ± Ã§alÄ±ÅŸtÄ±rmak deÄŸil; aynÄ± zamanda:

### âœ” HÄ±zlarÄ±nÄ± Ã¶lÃ§mek

### âœ” DoÄŸruluklarÄ±nÄ± karÅŸÄ±laÅŸtÄ±rmak

### âœ” FarklÄ± senaryolarda hangi algoritmanÄ±n kazandÄ±ÄŸÄ±nÄ± tespit etmek

### âœ” Pre-analysis (Ã¶n analiz) ile **Ã¶ngÃ¶rÃ¼ yapÄ±p doÄŸru algoritmayÄ± otomatik seÃ§mek**

Bu yÃ¶nÃ¼yle proje hem **teorik** hem **uygulamalÄ±** deÄŸer taÅŸÄ±r.

---

# 1. **String Matching Problemi**

AmaÃ§:
Bir metin (**text**) iÃ§inde bir desenin (**pattern**) eÅŸleÅŸtiÄŸi tÃ¼m konumlarÄ± bulmak.

Ã–rnek:

* Text: `"AABAACAADAABAABA"`
* Pattern: `"AABA"`
* Ã‡Ä±ktÄ±: `[0, 9, 12]`

Bu problem:

* editÃ¶rlerde â€œCTRL+Fâ€
* veri tabanlarÄ±nda arama
* DNA/protein dizisi eÅŸleÅŸmesi
* log tarama
  gibi alanlarÄ±n temelini oluÅŸturduÄŸu iÃ§in kritik Ã¶neme sahiptir.

---

# 2. **Sistemdeki Algoritmalar**

Projede **beÅŸ farklÄ± algoritma** iÃ§in bir Ã§atÄ± sÄ±nÄ±f (`Solution`) var.
Her algoritma kendi sÄ±nÄ±fÄ±nda implement edilmiÅŸtir.

### 2.1 Naive (Brute-Force)

* Her pozisyonda pattern'i tek tek dener.
* Zaman karmaÅŸÄ±klÄ±ÄŸÄ± **O(n * m)**
* KÃ¼Ã§Ã¼k desenlerde ve Ã§ok kÄ±sa textâ€™lerde ÅŸaÅŸÄ±rtÄ±cÄ± derecede iyi olabilir.

### 2.2 KMP (Knuth-Morris-Pratt)

* Patternâ€™in kendi iÃ§indeki tekrarlarÄ± analiz eder.
* Prefix function (LPS tablosu) sayesinde geri dÃ¶nÃ¼ÅŸ yapmaz.
* En kÃ¶tÃ¼ zaman: **O(n + m)**
* Tekrarlayan prefix barÄ±ndÄ±ran patternâ€™lerde gÃ¼Ã§lÃ¼.

### 2.3 Rabin-Karp

* Hashing tabanlÄ±dÄ±r.
* TÃ¼m eÅŸleÅŸmeleri hash Ã¼zerinden kontrol eder.
* Ortalama: **O(n + m)**
* En kÃ¶tÃ¼: **O(n*m)**
* BÃ¼yÃ¼k text ve uzun pattern senaryolarÄ±nda iyi performans verir.

### 2.4 Boyer-Moore

* Ä°ki temel kuralÄ± vardÄ±r:

  * Bad Character Rule
  * Good Suffix Rule
* Patternâ€™i saÄŸdan sola okur â†’ bÃ¼yÃ¼k hÄ±z kazandÄ±rÄ±r.
* BÃ¼yÃ¼k alfabe ve uzun patternâ€™lerde en hÄ±zlÄ±sÄ± olabilir.

### 2.5 GoCrazy (Hybrid)

* Boyer-Moore + Rabin-Karp + Lokal Quick Checks gibi hibrit teknikler iÃ§erir.
* AmaÃ§, SOTA olmayan ama pratikte iÅŸe yarayan bir â€œÃ§Ä±lgÄ±n hÄ±zlÄ±â€ Ã§Ã¶zÃ¼m yaratmaktÄ±r.
* Senin projende Ã¶zgÃ¼n bir algoritma olarak bulunuyor (Ã¶dev iÃ§in gÃ¼zel fikir).

---

# 3. **Pre-Analysis (Ã–n Algoritma SeÃ§imi)**

Bu sistemin gerÃ§ek zekÃ¢sÄ± burada.

KullanÄ±cÄ± input vermeden Ã¶nce algoritmayÄ± seÃ§mek iÃ§in Ã§eÅŸitli heuristics Ã§alÄ±ÅŸÄ±yor:

### KullanÄ±lan kriterler:

1. **Pattern uzunluÄŸu**

   * `<= 2` â†’ Naive
     (Zaten KMPâ€™nin hazÄ±rlÄ±k maliyeti gereksiz olur.)

2. **Patternâ€™in kendi iÃ§inde tekrar eden prefix olmasÄ±**

   * varsa â†’ KMP seÃ§ilir
     (LPS tablosu avantaj saÄŸlar.)

3. **Alfabe boyutu**

   * bÃ¼yÃ¼kse â†’ Boyer-Moore
     (Bad character tablosu daha etkili olur.)

4. **Pattern uzunluÄŸu orta ve bÃ¼yÃ¼kse**

   * Boyer-Moore veya GoCrazy tercih edilir.

Bu sayede proje sadece test etmiyor ayrÄ±ca:

* â€œPre-analysis doÄŸru tahmin yaptÄ± mÄ±?â€
* â€œSistem doÄŸru algoritmayÄ± seÃ§meyi Ã¶ÄŸreniyor mu?â€

gibi analizler de yapÄ±yor.

---

# 4. **Test Sistemi**

Testler JSON dosyalarÄ±ndan okunur. Her test ÅŸunlarÄ± iÃ§erir:

* text
* pattern
* expected result (Ã¶r. `[0, 9, 12]`)

Sistem her algoritmayÄ± sÄ±rayla Ã§alÄ±ÅŸtÄ±rÄ±r:

### âœ” DoÄŸruluk testi

`result == expected` ?

### âœ” SÃ¼re Ã¶lÃ§Ã¼mÃ¼

nanoTime â†’ mikrosaniyeye Ã§evirilir.

### âœ” Kazanan belirleme

en kÃ¼Ã§Ã¼k sÃ¼reyi alan algoritma â†’ "Winner"

### âœ” Pre-analysisâ€™Ä±n seÃ§tiÄŸi algoritma doÄŸru mu?

â€œPredicted winnerâ€ vs â€œActual winnerâ€

Bu Ã§ok deÄŸerli Ã§Ã¼nkÃ¼ projenin Ã¶ÄŸrenme/heuristic tarafÄ±nÄ± gÃ¼Ã§lendiriyor.

---

# 5. **Ã‡Ä±ktÄ± TablolarÄ±**

Ã–rnek:

```
Test Case          BoyerMoore  Naive   KMP     RabinKarp  GoCrazy  Winner
Simple Match       16.19 Î¼s    9.79 Î¼s 10.79 Î¼s 10.71 Î¼s  15.88 Î¼s ğŸ† Naive
```

Bu tablo bize ÅŸunlarÄ± sÃ¶yler:

* Naive kÃ¼Ã§Ã¼k text'lerde hÃ¢lÃ¢ Ã§ok hÄ±zlÄ±.
* Boyer-Moore ancak daha bÃ¼yÃ¼k alphabede fark yaratÄ±r.
* KMP prefix avantajÄ± olmayan patternlerde ortalama hÄ±zda kalÄ±r.
* GoCrazy bazÄ± testlerde Ã§ok hÄ±zlÄ± olabilir, bazÄ±larÄ±nda Ã§ok kÃ¶tÃ¼ olabilir.

---

# 6. **Projenin Ã–nemi**

Bu proje bir â€œimplementasyon Ã¶deviâ€ olmanÄ±n Ã§ok Ã¶tesinde:

### âœ” 1. AlgoritmalarÄ±n davranÄ±ÅŸÄ±nÄ± gerÃ§ek veride gÃ¶zlemlemeyi saÄŸlÄ±yor

Teorik Big-O gerÃ§ek hÄ±z demek deÄŸildir.

### âœ” 2. Her algoritmanÄ±n gÃ¼Ã§lÃ¼/zayÄ±f yanlarÄ±nÄ± gÃ¶steriyor

* Boyer-Moore â†’ bÃ¼yÃ¼k alfabe
* KMP â†’ tekrar eden prefix
* RK â†’ uzun pattern
* GoCrazy â†’ hibrit deneme

### âœ” 3. Pre-analysis ile otomatik algoritma seÃ§imi yapÄ±yor

Bu yaklaÅŸÄ±m:

* editÃ¶rlerde
* arama motorlarÄ±nda
* biyoinformatikte
  aktif olarak kullanÄ±lÄ±yor.

### âœ” 4. GeniÅŸletilebilir mimari

Yeni algoritmalar eklemek Ã§ok kolay:

* `Solution` extends edilip
* `findAll` implement edilerek
* analysis'e eklenir

---

# 7. **Genel Ã–zet**

Bu proje; sadece algoritmalarÄ±n kodlandÄ±ÄŸÄ± bir Ã§alÄ±ÅŸma deÄŸil,
**algoritmalarÄ±n davranÄ±ÅŸlarÄ±nÄ±n bilimsel olarak Ã¶lÃ§Ã¼ldÃ¼ÄŸÃ¼ ve yorumlandÄ±ÄŸÄ± bir analiz platformudur.**

### Sistemde:

* 5 algoritma implement edilmiÅŸtir
* Pre-analysis algoritma seÃ§imi yapÄ±lÄ±r
* Her testte hÄ±z + doÄŸruluk Ã¶lÃ§Ã¼lÃ¼r
* Kazanan algoritma belirlenir
* Tahminin doÄŸruluÄŸu hesaplanÄ±r
* Tablolarla profesyonel sonuÃ§ Ã§Ä±ktÄ±sÄ± Ã¼retilir

GerÃ§ek bir benchmark sisteminin minyatÃ¼r akademik versiyonudur.
